<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Scan This Scam</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <link rel="stylesheet" href="./styles.css">
  <script src="https://js.stripe.com/v3/"></script> <!-- New: Stripe.js script -->
</head>
<body>
  <header>
    <div class="header-left-group">
      <img src="logo-placeholder.png" alt="Logo" class="logo" />
      <strong>Scan This Scam</strong>
    </div>
    <h1 class="header-slogan">Smart Detection. Clear Guidance. Safer Decisions.</h1>
    <div class="button-group">
      <button type="button" class="cta-button" id="loginBtn">Login</button>
      <button type="button" class="cta-button" id="myScansBtn" style="display: none;">My Scans</button>
      <button type="button" class="cta-button" id="manageSubscriptionBtn" style="display: none;">Manage Subscription</button>
      <button type="button" class="cta-button" id="logoutBtn" style="display: none;">Logout</button>
    </div>
  </header>

  <!-- New: Authentication and User Sections -->
  <section class="auth-section" id="authSection" style="display: none;">
    <div class="auth-container">
      <button type="button" class="auth-close-btn" id="authCloseBtn">&times;</button>
      <div class="auth-form" id="loginForm">
        <h2>Login</h2>
        <input type="email" id="loginEmail" placeholder="Email" required>
        <input type="password" id="loginPassword" placeholder="Password" required>
        <button id="authLoginBtn">Login</button>
        <p>Don't have an account? <a href="#" id="showSignup">Sign Up</a></p>
      </div>
      <div class="auth-form" id="signupForm" style="display: none;">
        <h2>Sign Up</h2>
        <input type="email" id="signupEmail" placeholder="Email" required>
        <input type="password" id="signupPassword" placeholder="Password" required>
        <button id="signupBtn">Sign Up</button>
        <p>Already have an account? <a href="#" id="showLogin">Login</a></p>
      </div>
    </div>
  </section>

  <section class="my-scans-section" id="myScansSection" style="display: none;">
    <div class="my-scans-container">
      <button type="button" class="my-scans-close-btn" id="scansCloseBtn">&times;</button>
      <h2>My Past Scans</h2>
      <button type="button" class="cta-button" id="filterScansBtn" style="margin-bottom: 1rem;">Filter Scans</button>
      
      <!-- New: Filter Panel -->
      <div class="filter-panel" id="filterPanel" style="display: none;">
        <div class="filter-group">
          <h4>Content Type</h4>
          <label><input type="checkbox" name="contentType" value="text"> Text</label>
          <label><input type="checkbox" name="contentType" value="image"> Image</label>
          <label><input type="checkbox" name="contentType" value="pdf"> PDF</label>
          <label><input type="checkbox" name="contentType" value="audio"> Audio</label>
        </div>
        <div class="filter-group">
          <h4>Risk Level</h4>
          <label><input type="checkbox" name="riskLevel" value="low"> Low (0-25)</label>
          <label><input type="checkbox" name="riskLevel" value="medium"> Medium (26-75)</label>
          <label><input type="checkbox" name="riskLevel" value="high"> High (76-100)</label>
        </div>
        <div class="filter-group">
          <h4>Date Range</h4>
          <label>Start Date: <input type="date" id="startDate"></label>
          <label>End Date: <input type="date" id="endDate"></label>
        </div>
        <div class="filter-actions">
            <button id="applyFiltersBtn">Apply Filters</button>
            <button id="resetFiltersBtn">Reset</button>
        </div>
      </div>

      <div id="pastScansList" class="all-results-container">
        <!-- Past analysis results will be loaded here -->
      </div>
    </div>
  </section>

  <section class="grid">
    <div class="card">
      <div class="card-icon"><i class="fas fa-comment-dots"></i></div>
      <div class="card-title">Message</div>
      <div class="card-description">Copy a text, email, or any other message and paste it below.</div>
      <a href="#">Learn more →</a>
    </div>
    <div class="card">
      <div class="card-icon"><i class="fas fa-envelope-open-text"></i></div>
      <div class="card-title">Email</div>
      <div class="card-description">Save the suspicious email to your computer and upload it below.</div>
      <a href="#">Learn more →</a>
    </div>
    <div class="card">
      <div class="card-icon"><i class="fas fa-microphone-alt"></i></div>
      <div class="card-title">Audio</div>
      <div class="card-description">Upload a voicemail or any other audio file to have in analyzed below.</div>
      <a href="#">Learn more →</a>
    </div>
  </section>

  <section class="dynamic-section">
    <div class="dropdown-wrapper">
      <!-- Removed: General Payment Button -->
      <div id="inputBox">
        <div class="input-container" id="inputContainer">
          <textarea 
            id="mainInput" 
            placeholder="Paste text, or drag and drop your files here..."
            class="main-input"
          ></textarea>
          <div class="input-overlay" id="inputOverlay">
            <div class="overlay-content">
              <i class="fas fa-cloud-upload-alt overlay-icon"></i>
              <p>Drop files here or paste content</p>
            </div>
          </div>
          <input type="file" id="fileInput" accept="image/*,audio/*,.txt,.pdf,.doc,.docx" style="display: none;">
        </div>
        <div class="file-preview" id="filePreview" style="display: none;">
          <div class="preview-item">
            <span id="fileName"></span>
            <button class="remove-btn" onclick="removeFile()">×</button>
          </div>
        </div>
        <div class="input-actions">
          <button class="add-to-queue-btn" id="addToQueueBtn" onclick="addToQueue()" disabled>
            <i class="fas fa-plus-circle"></i> Queue
          </button>
          <button class="analyze-btn" id="analyzeBtn" onclick="analyzeContent()" disabled>
            <i class="fas fa-shield-alt"></i>
            Analyze for Scams
          </button>
        </div>
      </div>
    </div>
  </section>

  <section class="pricing-section" id="pricingSection" style="display: none;">
    <h2>Choose Your Analysis Plan</h2>
    <div class="pricing-grid">

      <!-- Monthly Plan Card -->
      <div class="pricing-card">
        <h3>Monthly Access</h3>
        <p class="price">$5<span>/month</span></p>
        <ul>
          <li><i class="fas fa-check-circle"></i> Unlimited Scam Analysis</li>
          <li><i class="fas fa-check-circle"></i> Real-time Threat Detection</li>
          <li><i class="fas fa-check-circle"></i> Actionable Safety Advice</li>
        </ul>
        <button class="select-plan-btn" data-plan-id="price_1Rq0bSRtn27UxH2dH6iRRm0A">Select Monthly</button>
      </div>

      <!-- Annual Plan Card -->
      <div class="pricing-card">
        <h3>Annual Access</h3>
        <p class="price">$50<span>/year</span></p>
        <ul>
          <li><i class="fas fa-check-circle"></i> All Monthly Features</li>
          <li><i class="fas fa-check-circle"></i> Save 10% Annually</li>
          <li><i class="fas fa-check-circle"></i> Priority Support</li>
        </ul>
        <button class="select-plan-btn" data-plan-id="price_1Rq0bSRtn27UxH2dtwAqaFOS">Select Annual</button>
      </div>

      <!-- Lifetime Plan Card -->
      <div class="pricing-card">
        <h3>Lifetime Access</h3>
        <p class="price">$100<span> one-time</span></p>
        <ul>
          <li><i class="fas fa-check-circle"></i> All Annual Features</li>
          <li><i class="fas fa-check-circle"></i> Never Pay Again</li>
          <li><i class="fas fa-check-circle"></i> Exclusive Early Access</li>
        </ul>
        <button class="select-plan-btn" data-plan-id="price_1Rq0bSRtn27UxH2dsAjGUmhu">Select Lifetime</button>
      </div>

    </div>
  </section>

  <section class="queue-section" id="queueSection" style="display: none;">
    <div class="queue-container">
      <h3>Items for Analysis (<span id="queueCount">0</span>)</h3>
      <ul id="queuedItemsList" class="queued-items-list"></ul>
      <button class="clear-queue-btn" id="clearQueueBtn" onclick="clearQueue()" style="display: none;">Clear All</button>
    </div>
  </section>

  <section class="results-section" id="resultsSection" style="display: none;">
    <div class="my-scans-container"> <!-- Re-using this class for consistent modal styling -->
      <button type="button" class="my-scans-close-btn" id="resultsCloseBtn">&times;</button>
      <h2>Analysis Results</h2>
      <div id="allResultsContainer" class="all-results-container">
        <!-- Individual analysis results will be appended here -->
      </div>
    </div>
  </section>

  <!-- New: Loading Modal -->
  <div class="loading-modal" id="loadingModal" style="display: none;">
      <div class="loading-container">
          <h2>Analyzing Your Content...</h2>
          <p>This may take a moment. Please wait.</p>
          <div class="spinner"></div>
      </div>
  </div>

  <footer>
    Scam Checking Service provided by Placeholder Inc.
  </footer>

  <script>
    let currentFile = null;
    let currentText = '';
    let currentPastedImage = null;
    let queuedItems = []; // New: Array to store items for batch analysis
    let itemIdCounter = 0; // New: Counter for unique item IDs
    
    // New: User authentication state
    let currentUser = {
      userId: null,
      email: null,
      token: null,
      isAuthenticated: false,
      isSubscribed: false
    };

    // New: Helper function to make authenticated API requests
    function fetchProtected(url, options = {}) {
      if (!currentUser.token) {
        throw new Error('No authentication token available');
      }
      
      const authOptions = {
        ...options,
        headers: {
          ...options.headers,
          'Authorization': `Bearer ${currentUser.token}`
        }
      };
      
      return fetch(url, authOptions);
    }

    // New: Function to load user from localStorage on page load
    function loadUserFromStorage() {
      const storedUser = localStorage.getItem('currentUser');
      if (storedUser) {
        try {
          currentUser = JSON.parse(storedUser);
          updateUIForAuth();
        } catch (error) {
          console.error('Error loading user from storage:', error);
          localStorage.removeItem('currentUser');
        }
      }
    }

    // New: Function to save user to localStorage
    function saveUserToStorage() {
      localStorage.setItem('currentUser', JSON.stringify(currentUser));
    }

    // New: Function to update UI based on authentication status
    function updateUIForAuth() {
      const authSection = document.getElementById('authSection');
      const myScansSection = document.getElementById('myScansSection');
      const dynamicSection = document.querySelector('.dynamic-section');
      const gridSection = document.querySelector('.grid');
      const pricingSection = document.getElementById('pricingSection');
      const loginBtn = document.getElementById('loginBtn');
      const myScansBtn = document.getElementById('myScansBtn');
      const logoutBtn = document.getElementById('logoutBtn');
      
      const manageSubscriptionBtn = document.getElementById('manageSubscriptionBtn');

      if (currentUser.isAuthenticated) {
        // User is logged in - show main app, hide auth
        authSection.style.display = 'none';
        dynamicSection.style.display = 'flex';
        gridSection.style.display = 'grid';
        // myScansSection can be shown/hidden separately
        
        // Update header buttons
        loginBtn.style.display = 'none';
        myScansBtn.style.display = 'inline-block';
        logoutBtn.style.display = 'inline-block';
        
        // Show/hide subscription management button in the main header
        manageSubscriptionBtn.style.display = currentUser.isSubscribed ? 'inline-block' : 'none';

        console.log('User logged in:', currentUser.email);
      } else {
        // User is not logged in - show auth, hide main app
        authSection.style.display = 'none'; // Hide auth by default, show only when needed
        dynamicSection.style.display = 'flex';
        gridSection.style.display = 'grid';
        myScansSection.style.display = 'none';
        pricingSection.style.display = 'none';
        
        // Update header buttons
        loginBtn.style.display = 'inline-block';
        myScansBtn.style.display = 'none';
        logoutBtn.style.display = 'none';
      }
    }

    // New: Function to handle logout
    function logout() {
      currentUser = {
        userId: null,
        email: null,
        token: null,
        isAuthenticated: false,
        isSubscribed: false
      };
      localStorage.removeItem('currentUser');
      updateUIForAuth();
    }

    // New: Function to load user's past scans with filters
    async function loadPastScans(filters = {}) {
      try {
        const query = new URLSearchParams(filters).toString();
        const response = await fetchProtected(`/api/user-scans?${query}`);
        if (response.ok) {
          const scans = await response.json();
          const pastScansList = document.getElementById('pastScansList');
          pastScansList.innerHTML = '';
          
          if (scans.length === 0) {
            pastScansList.innerHTML = '<p>No past scans found matching your criteria.</p>';
            return;
          }
          
          scans.forEach(scan => {
            const scanCard = document.createElement('div');
            scanCard.className = 'analysis-card-collapsible';

            // Use the submissionType field from the database
            let scanDetails = scan.submissionType || 'file'; // Fallback to 'file'

            scanCard.innerHTML = `
              <div class="collapsible-header">
                <h3>Scan from ${new Date(scan.createdAt).toLocaleDateString()}</h3>
                <p>${scanDetails.charAt(0).toUpperCase() + scanDetails.slice(1)}</p>
                <div class="header-right-group">
                  <div class="risk-score-badge"></div>
                  <button class="expand-btn"><i class="fas fa-chevron-down"></i></button>
                </div>
              </div>
              <div class="collapsible-content">
                <div class="risk-score">
                  <div class="score-circle">
                    <span>${scan.result.riskScore || 0}</span>
                  </div>
                  <h3>Risk Score</h3>
                </div>
                <div class="analysis-content">
                  <div class="analysis-section">
                    <h3><i class="fas fa-exclamation-triangle"></i> Red Flags</h3>
                    <ul class="redFlags"></ul>
                  </div>
                  <div class="analysis-section">
                    <h3><i class="fas fa-bug"></i> Potential Threats</h3>
                    <ul class="threats"></ul>
                  </div>
                  <div class="analysis-section">
                    <h3><i class="fas fa-lightbulb"></i> Recommendations</h3>
                    <ul class="recommendations"></ul>
                  </div>
                  <div class="analysis-section">
                    <h3><i class="fas fa-shield-alt"></i> Safety Tips</h3>
                    <ul class="safetyTips"></ul>
                  </div>
                </div>
              </div>
            `;
            
            // Populate the scan data
            const score = scan.result.riskScore || 0;
            
            // New: Populate and color-code the header badge
            const riskBadge = scanCard.querySelector('.risk-score-badge');
            riskBadge.textContent = score;
            if (score >= 76) { riskBadge.classList.add('high-risk'); }
            else if (score >= 26) { riskBadge.classList.add('medium-risk'); }
            else { riskBadge.classList.add('low-risk'); }

            // Populate the large score circle inside the collapsible
            const scoreCircle = scanCard.querySelector('.score-circle');
            const riskScoreSpan = scoreCircle.querySelector('span');
            if (riskScoreSpan) {
              riskScoreSpan.textContent = score;
              if (score >= 76) { scoreCircle.style.backgroundColor = '#ef4444'; }
              else if (score >= 26) { scoreCircle.style.backgroundColor = '#f59e0b'; }
              else { scoreCircle.style.backgroundColor = '#10b981'; }
            }

            updateList(scanCard.querySelector('.redFlags'), scan.result.redFlags || []);
            updateList(scanCard.querySelector('.threats'), scan.result.threats || []);
            updateList(scanCard.querySelector('.recommendations'), scan.result.recommendations || []);
            updateList(scanCard.querySelector('.safetyTips'), scan.result.safetyTips || []);
            
            pastScansList.appendChild(scanCard);
          });

          // Add event listeners for collapsibles
          document.querySelectorAll('.collapsible-header').forEach(header => {
            header.addEventListener('click', () => {
              header.parentElement.classList.toggle('active');
              const icon = header.querySelector('.expand-btn i');
              icon.classList.toggle('fa-chevron-down');
              icon.classList.toggle('fa-chevron-up');
            });
          });
        } else {
          console.error('Failed to load past scans');
        }
      } catch (error) {
        console.error('Error loading past scans:', error);
      }
    }

    // Main input elements
    const mainInput = document.getElementById('mainInput');
    const inputContainer = document.getElementById('inputContainer');
    const inputOverlay = document.getElementById('inputOverlay');
    const fileInput = document.getElementById('fileInput');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const addToQueueBtn = document.getElementById('addToQueueBtn'); // New: Add to Queue button

    // Queue elements
    const queueSection = document.getElementById('queueSection'); // New
    const queueCountSpan = document.getElementById('queueCount'); // New
    const queuedItemsList = document.getElementById('queuedItemsList'); // New
    const clearQueueBtn = document.getElementById('clearQueueBtn'); // New

    // New: Auth form elements
    const loginForm = document.getElementById('loginForm');
    const signupForm = document.getElementById('signupForm');
    const authLoginBtn = document.getElementById('authLoginBtn'); // Renamed to avoid conflict with header loginBtn
    const signupBtn = document.getElementById('signupBtn');
    const showSignupLink = document.getElementById('showSignup');
    const showLoginLink = document.getElementById('showLogin');

    // New: Auth event listeners
    showSignupLink.addEventListener('click', (e) => {
      e.preventDefault();
      loginForm.style.display = 'none';
      signupForm.style.display = 'block';
    });

    showLoginLink.addEventListener('click', (e) => {
      e.preventDefault();
      signupForm.style.display = 'none';
      loginForm.style.display = 'block';
    });

    // New: Header button event listeners
    document.getElementById('loginBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      document.getElementById('authSection').style.display = 'block';
      document.getElementById('authSection').scrollIntoView({ behavior: 'smooth' });
    });

    document.getElementById('myScansBtn').addEventListener('click', (e) => {
      e.preventDefault();
      document.getElementById('myScansSection').style.display = 'block';
      loadPastScans(); // Load user's past scans
    });

    document.getElementById('logoutBtn').addEventListener('click', (e) => {
      e.preventDefault();
      logout();
    });

    // Close auth window
    document.getElementById('authCloseBtn').addEventListener('click', (e) => {
      e.preventDefault();
      document.getElementById('authSection').style.display = 'none';
    });

    document.getElementById('manageSubscriptionBtn').addEventListener('click', async (e) => {
      e.preventDefault();
      try {
        const response = await fetchProtected('/create-portal-session', {
          method: 'POST'
        });
        if (response.ok) {
          const { url } = await response.json();
          window.location.href = url;
        } else {
          const errorData = await response.json();
          alert('Could not open subscription management: ' + (errorData.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Error creating customer portal session:', error);
        alert('Error creating customer portal session. Please try again later.');
      }
    });

    // New: Filter functionality
    document.getElementById('filterScansBtn').addEventListener('click', () => {
        const filterPanel = document.getElementById('filterPanel');
        filterPanel.style.display = filterPanel.style.display === 'none' ? 'block' : 'none';
    });

    document.getElementById('applyFiltersBtn').addEventListener('click', () => {
        const contentTypes = Array.from(document.querySelectorAll('input[name="contentType"]:checked')).map(el => el.value);
        const riskLevels = Array.from(document.querySelectorAll('input[name="riskLevel"]:checked')).map(el => el.value);
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;

        const filters = {};
        if (contentTypes.length) filters.contentTypes = contentTypes.join(',');
        if (riskLevels.length) filters.riskLevels = riskLevels.join(',');
        if (startDate) filters.startDate = startDate;
        if (endDate) filters.endDate = endDate;

        console.log('Applying filters:', filters); // New: Debugging log
        loadPastScans(filters);
    });

    document.getElementById('resetFiltersBtn').addEventListener('click', () => {
        document.querySelectorAll('input[name="contentType"]').forEach(el => el.checked = false);
        document.querySelectorAll('input[name="riskLevel"]').forEach(el => el.checked = false);
        document.getElementById('startDate').value = '';
        document.getElementById('endDate').value = '';
        loadPastScans();
    });

    // Close scans window
    document.getElementById('scansCloseBtn').addEventListener('click', (e) => {
        e.preventDefault();
        document.getElementById('myScansSection').style.display = 'none';
    });

    // New: Close results window
    document.getElementById('resultsCloseBtn').addEventListener('click', (e) => {
        e.preventDefault();
        document.getElementById('resultsSection').style.display = 'none';
    });

    signupBtn.addEventListener('click', async (e) => {
      e.preventDefault();
      const email = document.getElementById('signupEmail').value;
      const password = document.getElementById('signupPassword').value;

      if (!email || !password) {
        alert('Please fill in all fields');
        return;
      }

      try {
        const response = await fetch('/signup', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email, password })
        });

        if (response.ok) {
          const data = await response.json();
          currentUser = {
            userId: data.userId,
            email: data.email,
            token: data.token,
            isAuthenticated: true,
            isSubscribed: data.isSubscribed || false
          };
          saveUserToStorage();
          updateUIForAuth();
          
          // Restore the queue after successful signup
          restoreQueueFromStorage();

          // Close the auth window and continue the flow
          document.getElementById('authSection').style.display = 'none';
          
          // Clear signup form
          document.getElementById('signupEmail').value = '';
          document.getElementById('signupPassword').value = '';
          
          // Re-trigger analysis flow
          analyzeContent();
        } else {
          const errorText = await response.text();
          alert('Signup failed: ' + errorText);
        }
      } catch (error) {
        console.error('Signup error:', error);
        alert('Signup failed: Network error');
      }
    });

    authLoginBtn.addEventListener('click', async (e) => {
      e.preventDefault();
      const email = document.getElementById('loginEmail').value;
      const password = document.getElementById('loginPassword').value;

      if (!email || !password) {
        alert('Please fill in all fields');
        return;
      }

      try {
        const response = await fetch('/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email, password })
        });

        if (response.ok) {
          const data = await response.json();
          currentUser = {
            userId: data.userId,
            email: data.email,
            token: data.token,
            isAuthenticated: true,
            isSubscribed: data.isSubscribed || false
          };
          saveUserToStorage();

          // Immediately check subscription status upon login
          await pollSubscriptionStatus(); 
          
          updateUIForAuth();

          // Restore the queue after successful login
          restoreQueueFromStorage();

          // Close the auth window
          document.getElementById('authSection').style.display = 'none';

          // Clear login form
          document.getElementById('loginEmail').value = '';
          document.getElementById('loginPassword').value = '';

          // Re-trigger analysis flow
          analyzeContent();
        } else {
          const errorText = await response.text();
          alert('Login failed: ' + errorText);
        }
      } catch (error) {
        console.error('Login error:', error);
        alert('Login failed: Network error');
      }
    });

    // Drag and drop over text field
    inputContainer.addEventListener('dragover', (e) => {
      e.preventDefault();
      inputOverlay.style.display = 'flex';
    });

    inputContainer.addEventListener('dragleave', (e) => {
      e.preventDefault();
      if (!inputContainer.contains(e.relatedTarget)) {
        inputOverlay.style.display = 'none';
      }
    });

    inputContainer.addEventListener('drop', (e) => {
      e.preventDefault();
      inputOverlay.style.display = 'none';
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        handleFile(files[0]);
      }
    });

    // Paste event handling
    mainInput.addEventListener('paste', (e) => {
      e.preventDefault();
      
      const items = e.clipboardData.items;
      let hasContent = false;

      for (let item of items) {
        if (item.type.indexOf('image') !== -1) {
          // Handle pasted image
          const file = item.getAsFile();
          handleFile(file);
          hasContent = true;
        } else if (item.type === 'text/plain') {
          // Handle pasted text
          item.getAsString((text) => {
            mainInput.value += text;
            currentText = mainInput.value;
            updateButtons(); // Changed from updateAnalyzeButton
          });
          hasContent = true;
        }
      }

      if (!hasContent) {
        // Fallback: try to get text from clipboard
        navigator.clipboard.readText().then(text => {
          if (text) {
            mainInput.value += text;
            currentText = mainInput.value;
            updateButtons(); // Changed from updateAnalyzeButton
          }
        }).catch(() => {
          // If clipboard API fails, allow default paste behavior
          e.stopPropagation();
        });
      }
    });

    // File input change
    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        handleFile(e.target.files[0]);
      }
    });

    // Text input change
    mainInput.addEventListener('input', (e) => {
      currentText = e.target.value;
      updateButtons(); // Changed from updateAnalyzeButton
    });

    function handleFile(file) {
      currentFile = file;
      showFilePreview(file.name);
      updateButtons(); // Changed from updateAnalyzeButton
    }

    function showFilePreview(fileName) {
      // Create or update file preview
      let filePreview = document.getElementById('filePreview');
      if (!filePreview) {
        filePreview = document.createElement('div');
        filePreview.id = 'filePreview';
        filePreview.className = 'file-preview';
        filePreview.innerHTML = `
          <div class="preview-item">
            <span id="fileName"></span>
            <button class="remove-btn" onclick="removeFile()">×</button>
          </div>
        `;
        inputContainer.parentNode.insertBefore(filePreview, inputContainer.nextSibling);
      }
      
      document.getElementById('fileName').textContent = fileName;
      filePreview.style.display = 'block';
    }

    function removeFile() {
      currentFile = null;
      currentPastedImage = null;
      const filePreview = document.getElementById('filePreview');
      if (filePreview) {
        filePreview.style.display = 'none';
      }
      updateButtons(); // Changed from updateAnalyzeButton
    }

    // New: Function to update both analyze and add to queue buttons
    function updateButtons() {
      const hasContent = (currentFile !== null) || (currentText.trim() !== '');
      analyzeBtn.disabled = queuedItems.length === 0; // Analyze button enabled only if queue has items
      addToQueueBtn.disabled = !hasContent; // Add to Queue button enabled if current input has content
    }

    // New: Add current input to queue
    function addToQueue() {
      if (currentFile) {
        queuedItems.push({
          id: itemIdCounter++,
          type: 'file',
          name: currentFile.name,
          data: currentFile // Store the File object
        });
        clearInput();
      } else if (currentText.trim()) {
        queuedItems.push({
          id: itemIdCounter++,
          type: 'text',
          content: currentText.trim()
        });
        clearInput();
      }
      updateQueueList();
      updateButtons();
    }

    // New: Clear the main input area
    function clearInput() {
      mainInput.value = '';
      currentText = '';
      removeFile(); // This also sets currentFile/currentPastedImage to null
    }

    // New: Update the displayed list of queued items
    function updateQueueList() {
      queuedItemsList.innerHTML = '';
      if (queuedItems.length > 0) {
        queueSection.style.display = 'block';
        clearQueueBtn.style.display = 'block';
        queuedItems.forEach(item => {
          const li = document.createElement('li');
          li.className = 'queued-item';
          li.innerHTML = `
            <span>${item.type === 'file' ? item.name : item.content.substring(0, 50) + (item.content.length > 50 ? '...' : '')}</span>
            <button class="remove-queued-item-btn" data-id="${item.id}">×</button>
          `;
          queuedItemsList.appendChild(li);
        });
        // Add event listeners for new remove buttons
        queuedItemsList.querySelectorAll('.remove-queued-item-btn').forEach(button => {
          button.addEventListener('click', (e) => removeQueuedItem(parseInt(e.target.dataset.id)));
        });
      } else {
        queueSection.style.display = 'none';
        clearQueueBtn.style.display = 'none';
      }
      queueCountSpan.textContent = queuedItems.length;
    }

    // New: Remove a specific item from the queue
    function removeQueuedItem(id) {
      queuedItems = queuedItems.filter(item => item.id !== id);
      updateQueueList();
      updateButtons();
    }

    // New: Clear all items from the queue
    function clearQueue() {
      queuedItems = [];
      updateQueueList();
      updateButtons();
    }

    // Modified analyzeContent to get analysisId and pass to displaySingleResult
    async function analyzeContent() {
      if (queuedItems.length === 0) {
        alert('Please add items to the queue before analyzing.');
        return;
      }

      if (!currentUser.isAuthenticated) {
        // Save the queue before showing the auth form
        sessionStorage.setItem('analysisQueue', JSON.stringify(queuedItems));
        document.getElementById('authSection').style.display = 'block';
        document.getElementById('authSection').scrollIntoView({ behavior: 'smooth' });
        return;
      }

      // If user is subscribed, bypass paywall
      if (currentUser.isSubscribed) {
        document.getElementById('resultsSection').style.display = 'block';
        document.getElementById('pricingSection').style.display = 'none';
        // Proceed with analysis and display results directly
        await processAndDisplaySubscribedUserResults();
        return;
      }

      // If user is not subscribed, show the pricing/paywall
      document.getElementById('pricingSection').style.display = 'block';
      document.getElementById('pricingSection').scrollIntoView({ behavior: 'smooth' });
    }

    async function processAndDisplaySubscribedUserResults() {
        const loadingModal = document.getElementById('loadingModal');
        loadingModal.style.display = 'flex'; // Show loading modal

        const allResultsContainer = document.getElementById('allResultsContainer');
        allResultsContainer.innerHTML = '';

        for (const item of queuedItems) {
            const formData = new FormData();
            if (item.type === 'file') {
                formData.append('file', item.data, item.name);
            } else if (item.type === 'text') {
                formData.append('text', item.content);
            }

            const resultCard = createResultCard(item);
            allResultsContainer.appendChild(resultCard);

            try {
                const response = await fetchProtected('/api/analyze', {
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();
                if (response.ok) {
                    await displaySubscribedResult(resultCard, result.analysisId);
                } else {
                    displayErrorOnCard(resultCard, result.error || 'Analysis failed');
                }
            } catch (error) {
                console.error('Error during analysis of item:', item, error);
                displayErrorOnCard(resultCard, 'Network Error: Could not connect to server.');
            }
        }

        loadingModal.style.display = 'none'; // Hide loading modal
        document.getElementById('resultsSection').style.display = 'block'; // Show results modal

        clearQueue();
        resetButtons();
    }

    function createResultCard(item) {
        const resultCard = document.createElement('div');
        resultCard.className = 'results-container analysis-card';
        resultCard.id = `result-card-${item.id}`;
        resultCard.innerHTML = `
            <h3>Analyzing: ${item.type === 'file' ? item.name : item.content.substring(0, 50) + (item.content.length > 50 ? '...' : '')}</h3>
            <div class="risk-score">
                <div class="score-circle loading-spinner">
                    <i class="fas fa-spinner fa-spin"></i>
                </div>
                <h3>Risk Score</h3>
            </div>
            <div class="analysis-content">
                <div class="analysis-section">
                    <h3><i class="fas fa-exclamation-triangle"></i> Red Flags</h3>
                    <ul class="redFlags"><li>Analyzing...</li></ul>
                </div>
                <div class="analysis-section">
                    <h3><i class="fas fa-bug"></i> Potential Threats</h3>
                    <ul class="threats"><li>Analyzing...</li></ul>
                </div>
                <div class="analysis-section">
                    <h3><i class="fas fa-lightbulb"></i> Recommendations</h3>
                    <ul class="recommendations"><li>Analyzing...</li></ul>
                </div>
                <div class="analysis-section">
                    <h3><i class="fas fa-shield-alt"></i> Safety Tips</h3>
                    <ul class="safetyTips"><li>Analyzing...</li></ul>
                </div>
            </div>
        `;
        return resultCard;
    }

    async function displaySubscribedResult(resultCard, analysisId) {
        if (!resultCard) return;

        try {
            const response = await fetchProtected(`/api/results/${analysisId}`);
            if (response.ok) {
                const fullResult = await response.json();
                populateResultCard(resultCard, fullResult);
            } else {
                const errorData = await response.json();
                displayErrorOnCard(resultCard, errorData.error || 'Failed to load results.');
            }
        } catch (error) {
            console.error('Error fetching subscribed result:', error);
            displayErrorOnCard(resultCard, 'Network error while fetching results.');
        }
    }

    function resetButtons() {
        analyzeBtn.innerHTML = '<i class="fas fa-shield-alt"></i> Analyze for Scams';
        analyzeBtn.disabled = queuedItems.length === 0;
        addToQueueBtn.disabled = false;
        clearQueueBtn.disabled = queuedItems.length === 0;
    }

    function displayErrorOnCard(card, errorDetails) {
        const scoreCircle = card.querySelector('.score-circle');
        scoreCircle.classList.remove('loading-spinner');
        scoreCircle.style.backgroundColor = '#ef4444'; // Red for error
        scoreCircle.innerHTML = `<span>!</span>`;

        const analysisContent = card.querySelector('.analysis-content');
        analysisContent.classList.remove('results-blurred');
        
        const redFlagsList = card.querySelector('.redFlags');
        updateList(redFlagsList, [`Error: ${errorDetails}`]);

        // Clear other lists
        updateList(card.querySelector('.threats'), []);
        updateList(card.querySelector('.recommendations'), []);
        updateList(card.querySelector('.safetyTips'), []);
    }

    function populateResultCard(card, resultData) {
        const analysisContent = card.querySelector('.analysis-content');
        analysisContent.classList.remove('results-blurred');

        const checkoutBtn = card.querySelector('.checkout-for-results-btn');
        if (checkoutBtn) checkoutBtn.style.display = 'none';

        const scoreCircle = card.querySelector('.score-circle');
        scoreCircle.classList.remove('loading-spinner');
        scoreCircle.innerHTML = `<span>${resultData.riskScore || 0}</span>`;
        const score = resultData.riskScore || 0;
        if (score >= 70) { scoreCircle.style.backgroundColor = '#ef4444'; }
        else if (score >= 40) { scoreCircle.style.backgroundColor = '#f59e0b'; }
        else { scoreCircle.style.backgroundColor = '#10b981'; }

        updateList(card.querySelector('.redFlags'), resultData.redFlags || []);
        updateList(card.querySelector('.threats'), resultData.threats || []);
        updateList(card.querySelector('.recommendations'), resultData.recommendations || []);
        updateList(card.querySelector('.safetyTips'), resultData.safetyTips || []);
    }

    // New: Function to initiate Stripe Checkout
    async function initiateCheckout(priceId) {
      // Save the queue to sessionStorage before redirecting
      sessionStorage.setItem('analysisQueue', JSON.stringify(queuedItems));

      try {
        const response = await fetchProtected('/create-checkout-session', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ priceId: priceId }),
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || 'Failed to create checkout session');
        }

        const session = await response.json();
        const stripe = Stripe('pk_test_51Rq0UfRtn27UxH2daBH0qVADulqyFux0tFfwI4GKLl7dMuMwZ3iQMEm4yCj7jNxaiDykALmRkPrFADbDUVreR83F00joLrFlJv'); // Replace with your actual publishable key
        stripe.redirectToCheckout({ sessionId: session.id });
      } catch (error) {
        console.error('Error initiating payment:', error);
        alert('Error initiating payment: ' + error.message);
        // Clear the stored queue if checkout fails
        sessionStorage.removeItem('analysisQueue');
      }
    }

    // Modified: updateList to accept an element directly
    function updateList(element, items) {
      element.innerHTML = '';
      if (items.length === 0) {
        const li = document.createElement('li');
        li.textContent = 'No items found or N/A.';
        element.appendChild(li);
        return;
      }
      items.forEach(item => {
        const li = document.createElement('li');
        li.textContent = item;
        element.appendChild(li);
      });
    }

    // New: Function to poll subscription status
    async function pollSubscriptionStatus() {
      if (!currentUser.isAuthenticated) {
        return;
      }
      try {
        const response = await fetchProtected('/api/user-subscription');
        if (response.ok) {
          const subscriptionData = await response.json();
          if (subscriptionData.isSubscribed !== currentUser.isSubscribed) {
            currentUser.isSubscribed = subscriptionData.isSubscribed;
            saveUserToStorage();
            updateUIForAuth(); // Update UI to reflect new subscription status
            console.log('Subscription status updated:', currentUser.isSubscribed);
          }
        } else {
          console.error('Failed to poll subscription status');
        }
      } catch (error) {
        console.error('Error polling subscription status:', error);
      }
    }

    // New: Function to restore queue from sessionStorage
    function restoreQueueFromStorage() {
      const savedQueue = sessionStorage.getItem('analysisQueue');
      if (savedQueue) {
        try {
          // Note: This restores the data, but not the File objects themselves.
          // This implementation will need to be adjusted if you need to re-upload files.
          // For now, we'll restore text-based items.
          const parsedQueue = JSON.parse(savedQueue);
          queuedItems = parsedQueue.filter(item => item.type === 'text');
          
          if (queuedItems.length > 0) {
            updateQueueList();
            updateButtons();
            console.log('Restored text-based items from previous session.');
          }

        } catch (error) {
          console.error('Error restoring queue from sessionStorage:', error);
        } finally {
          // Clear the storage after attempting to restore
          sessionStorage.removeItem('analysisQueue');
        }
      }
    }

    // Initial setup
    updateButtons();
    
    // New: Add event listeners for plan selection buttons
    document.querySelectorAll('.select-plan-btn').forEach(button => {
      button.addEventListener('click', (e) => {
        const priceId = e.target.dataset.planId;
        initiateCheckout(priceId);
      });
    });
    
    // New: Load user from storage and update UI on page load
    loadUserFromStorage();
    restoreQueueFromStorage();
    
    // New: Check for payment status only if user is authenticated
    if (currentUser.isAuthenticated) {
      // Start polling for subscription status
      setInterval(pollSubscriptionStatus, 5000); // Poll every 5 seconds
    }
  </script>
</body>
</html> 